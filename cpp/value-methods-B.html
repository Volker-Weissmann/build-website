<figure class="highlight"><section><pre><code>
  <span class='c'>// Defined only for symbols. Return a pointer to a string</span>
  <span class='c'>// that contains the textual representation of the symbol</span>
  <span class='c'>// Do not try to deallocate the returned string</span>
  <span class='k'>const</span> <span class='b'>char</span> *as_symb();

  <span class='c'>// Defined only for integers</span>
  <span class='c'>// Returns the value as a 64-bit signed integer</span>
  <span class='b'>long</span> <span class='b'>long</span> as_int();

  <span class='c'>// Defined only for floating point numbers</span>
  <span class='c'>// Returns the value as a double precision floating point number</span>
  <span class='b'>double</span> as_float();

  <span class='c'>// Defined for all collection types:</span>
  <span class='c'>// sequences, sets, binary and ternary relations</span>
  <span class='b'>unsigned</span> <span class='b'>int</span> size();

  <span class='c'>// Defined only for sequences and sets</span>
  <span class='c'>// Returns the i-th value in the collection</span>
  <span class='c'>// In the case of sets, elements are arranged</span>
  <span class='c'>// in an implementation-defined order</span>
  <span class='m'>Value</span> *item(<span class='b'>unsigned</span> <span class='b'>int</span>);

  <span class='c'>// Defined only for binary relations</span>
  <span class='c'>// Returns the i-th pair in the relation</span>
  <span class='c'>// Pairs are arranged in an implementation-defined order</span>
  <span class='b'>void</span> entry(<span class='b'>unsigned</span> <span class='b'>int</span>, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;);

  <span class='c'>// Defined only for ternary relations</span>
  <span class='c'>// Returns the i-th triple in the relation</span>
  <span class='c'>// Entries are arranged in an implementation-defined order</span>
  <span class='b'>void</span> entry(<span class='b'>unsigned</span> <span class='b'>int</span>, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;);

  <span class='c'>// Defined only for tagged values</span>
  <span class='c'>// Returns the textual representation of the tag</span>
  <span class='c'>// Again, do not try to deallocate the returned string</span>
  <span class='k'>const</span> <span class='b'>char</span> *tag();

  <span class='c'>// Defined only for tagged values</span>
  <span class='c'>// Returns the value without the tag</span>
  <span class='m'>Value</span> *untagged();

  <span class='c'>// Defined only for strings</span>
  <span class='c'>// Returns the string in UTF-8 format</span>
  std::string as_str();

  <span class='c'>// Defined only for records</span>
  <span class='c'>// Returns the value of the corresponding field</span>
  <span class='c'>// The only parameter is the textual representation of the</span>
  <span class='c'>// field symbol, e.g. point.lookup("x")</span>
  <span class='m'>Value</span> *lookup(<span class='k'>const</span> <span class='b'>char</span> *);
</code></pre></section></figure>
